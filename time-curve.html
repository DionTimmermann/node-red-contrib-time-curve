<script type="text/javascript">

    const secondsPerDay = 24 * 60 * 60;
    const maxY = 100;

    function secondsToTime(sec) {
        const hours = Math.floor(sec / 3600);
        const minutes = Math.floor((sec % 3600) / 60);
        const seconds = Math.floor(sec % 60);

        // Pad with leading zeros
        const pad = (n) => n.toString().padStart(2, '0');

        let time = `${pad(hours)}:${pad(minutes)}`;
        if (seconds !== 0) {
            time += `:${pad(seconds)}`;
        }

        return time;
    }

    function timeToSeconds(timeStr) {
        if (typeof timeStr !== "string" || timeStr.trim() === "") {
            throw new Error("Input must be a non-empty time string (hh:mm or hh:mm:ss).");
        }

        const parts = timeStr.trim().split(":");
        if (parts.length < 2 || parts.length > 3) {
            throw new Error("Invalid time format â€” expected hh:mm or hh:mm:ss.");
        }

        const [hStr, mStr, sStr] = parts;
        const hours = Number(hStr);
        const minutes = Number(mStr);
        const seconds = sStr !== undefined ? Number(sStr) : 0;

        if (!Number.isFinite(hours) || !Number.isFinite(minutes) || (sStr !== undefined && !Number.isFinite(seconds))) {
            throw new Error("Non-numeric value in time string.");
        }

        return hours * 3600 + minutes * 60 + seconds;
    }

    function clamp(value, min = null, max = null) {
        if (min !== null && value < min) value = min;
        if (max !== null && value > max) value = max;
        return value;
    }

    function parseFiniteNumber(value) {
        const num = Number(value);
        if (typeof value === "boolean" || value === null || value === "" || !Number.isFinite(num)) {
            throw new Error(`Non-finite number.`);
        }
        return num;
    }

    function parsePoints() {
        let points = $('#node-input-points-container').editableList('items');
        let list = [];
        let errorState = false;
        points.each(function (i) {
            let x = undefined;
            let y = undefined;
            try {
                x = timeToSeconds($(this).find('.coord-input-x').val());

                // If we reach this point, there is no error.
                $(this).find('.coord-input-x')
                    .removeClass("input-error")
                    .removeAttr("title");
            } catch (e) {
                $(this).find('.coord-input-x')
                    .addClass("input-error")
                    .attr("title", e.text);
                errorState = true;
            }
            try {
                y = parseFiniteNumber($(this).find('.coord-input-y').val());

                // If we reach this point, there is no error.
                $(this).find('.coord-input-y')
                    .removeClass("input-error")
                    .removeAttr("title");
            } catch (e) {
                $(this).find('.coord-input-y')
                    .addClass("input-error")
                    .attr("title", e.text);
                errorState = true;
            }

            const uuid = $(this).find('.coord-input-uuid').val();
            list.push({x: x, y: y, uuid: uuid});
        });

        if (errorState) {
            return [];
        } else {
            list.sort((a, b) => a.x - b.x);
            return list;
        }
    }

    function isEmptyObject(obj) {
        return obj && Object.keys(obj).length === 0 && obj.constructor === Object;
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    function Curve(){
        'use strict';

        this.points 		= [];
        this.onAddPoint		= function(index, point){};
        this.onMovePoint    = function(index, point){};
        this.onRemovePoint  = function(index, point){};

        this.addPoint = function(point){
            if (point.uuid === undefined) {
                point.uuid = generateUUID();
            }

            let index = this.points.findIndex(p => p.x > point.x);
            if (index === -1) {
                this.points.push(point);
            } else {
                this.points.splice(index, 0, point);
            }

            this.onAddPoint(point);
            return index;
        }

        this.removePoint = function(point){
            const index = this.points.findIndex(p => p.uuid === point.uuid);

            if (index !== -1) {
                this.points.splice(index, 1);
                this.onRemovePoint(point);
            }
        }

        this.movePoint = function(pointIndex, newValue){
            this.points[pointIndex].x = newValue.x;
            this.points[pointIndex].y = newValue.y;
            this.onMovePoint(this.points[pointIndex]);
        }

        this.getExtendedPoints = function() {
            const points = this.points;
            return [
                { x: points[points.length - 1].x - secondsPerDay, y: points[points.length - 1].y },
                ...points,
                { x: points[0].x + secondsPerDay, y: points[0].y }
            ];
        }
    }

    function CurveView(canvas, container, curve){
        'use strict';

        this.currentPoint = -1;
        this.canvas			= canvas;
        this.canvas.width   = canvas.clientWidth;
        this.canvas.height  = 300;
        this.container      = container;
        this.curve          = curve;
        this.ctx 			= this.canvas.getContext('2d');
        this.redrawInterval = 50;

        this.point_selection_threshold = 60*15;

        this.updateSize = function() {
            this.canvas.width = this.container.clientWidth;
        }

        this.canvas.addEventListener('mousedown', (ev) => {
            this.mouseDown(ev);
        }, false);

        this.canvas.addEventListener('contextmenu', (ev) => {
            this.rightClick(ev);
        }, false);

        this.canvas.addEventListener('mouseup', (ev) => {
            this.mouseUp(ev);
        }, false);

        this.canvas.addEventListener('mousemove', (ev) => {
            this.mouseMove(ev);
        }, false);

        this.pixelPositions = function(points) {
            const width = this.canvas.width;
            const height = this.canvas.height;
            return points.map(p => ({
                px: p.x * width / secondsPerDay,
                py: height - p.y * height / maxY
            }));
        }

        this.render = function() {
            'use strict';

            const ctx = this.ctx;
            const width = this.canvas.width;
            const height = this.canvas.height;

            ctx.clearRect(0, 0, width, height);
            this.drawBorder(ctx);

            if (this.curve.points.length === 0) {

                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#aaa';

                ctx.moveTo(0, 0);
                ctx.lineTo(width, height);
                ctx.moveTo(width, 0);
                ctx.lineTo(0, height);
                ctx.stroke();

                ctx.clearRect(width/2 - 75, height/2 - 25, 150, 50);

                ctx.font = "14px Arial";
                ctx.fillStyle = "#999";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("Invalid data table!", width/2, height/2 - 10);
                ctx.fillText("Correct data in table below to enable GUI.", width/2, height/2 + 10);

            } else {
                const extended = this.pixelPositions(this.curve.getExtendedPoints());
                this.drawGrid(ctx);

                // Draw line
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#000';
                ctx.moveTo(extended[0].px, extended[0].py);
                for (let i = 1; i < extended.length; i++) {
                    ctx.lineTo(extended[i].px, extended[i].py);
                }
                ctx.stroke();

                // Draw points
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                for (let i = 1; i < extended.length - 1; i++) {
                    ctx.moveTo(extended[i].px, extended[i].py);
                    ctx.arc(extended[i].px, extended[i].py, 3, 0, 2 * Math.PI);
                }
                ctx.fill();
            }
        }

        // The background border
        this.drawBorder = function(ctx) {
            'use strict';

            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000000';
            ctx.rect(0, 0, this.canvas.width, this.canvas.height);
            ctx.stroke();
        }

        // The background grid
        this.drawGrid = function(ctx) {
            'use strict';

            const width = this.canvas.width;
            const height = this.canvas.height;

            // horrizontal lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#aaa';
            let numSections = 4;
            for (let i=1; i<numSections; i++) {
                let yCoord = Math.round(i * height/numSections);
                ctx.moveTo(0, yCoord);
                ctx.lineTo(width, yCoord);
            }
            ctx.stroke();

            // thin vertical lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ddd';
            numSections = 24;
            for (let i=1; i<numSections; i++) {
                if (i%6 == 0) {
                    continue;
                }
                let xCoord = Math.round(i * width/numSections);
                ctx.moveTo(xCoord, 0); ctx.lineTo(xCoord, height);
            }
            ctx.stroke();

            // dark vertical lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#999';
            numSections = 4;
            for (let i=1; i<numSections; i++) {
                let xCoord = Math.round(i * width/numSections);
                ctx.moveTo(xCoord, 0); ctx.lineTo(xCoord, height-16); // Offset a bit for the text
            }
            ctx.stroke();

            ctx.font = "14px Arial";
            ctx.fillStyle = "#999";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("6:00",  width * 1 / 4, height);
            ctx.fillText("12:00", width * 2 / 4, height);
            ctx.fillText("18:00", width * 3 / 4, height);

            ctx.textAlign = "left";    // left, right, center
            ctx.textBaseline = "top";
            ctx.fillText("25%",  2, height * 3 / 4);
            ctx.fillText("50%",  2, height * 2 / 4);
            ctx.fillText("75%",  2, height * 1 / 4);
            ctx.fillText("100%", 2, height * 0 / 4);
        }

        this.getCoordinateFromEvent = function(event){
            if(!event) var event = window.event;
            var canvasRect = this.canvas.getBoundingClientRect();
            var pointerCoordinate = {
                px: event.pageX - canvasRect.left,
                py: event.pageY - canvasRect.top
            }
            return pointerCoordinate;
        }

        this.mouseDown = function(event) {
            'use strict';

            if (this.curve.points.length === 0) {
                return;
            }
            const click = this.getCoordinateFromEvent(event);

            const points = this.pixelPositions(this.curve.points);
            const distances = points.map(p => Math.sqrt((p.px - click.px)**2 + (p.py - click.py)**2));
            const minDist = Math.min(...distances);

            if (minDist <= 10) {
                this.currentPoint = distances.indexOf(minDist);
            } else {
                const newPoint = {
                    x: Math.round(click.px / canvas.width * secondsPerDay),
                    y: Math.round((1 - (click.py / canvas.height)) * maxY)
                }

                this.currentPoint = this.curve.addPoint(newPoint); // addPoint returns the index.
            }
        }

        this.rightClick = function(event) {
            'use strict';
            if (this.curve.points.length <= 1) {
                return;
            }

            const click = this.getCoordinateFromEvent(event);

            const points = this.pixelPositions(this.curve.points);
            const distances = points.map(p => Math.sqrt((p.px - click.px)**2 + (p.py - click.py)**2));
            const minDist = Math.min(...distances);

            if (minDist <= 10) {
                const point = this.curve.points[distances.indexOf(minDist)];
                this.curve.removePoint(point);
                event.preventDefault();
            }
        }

        this.mouseUp = function(event) {
            'use strict';
            this.currentPoint = -1;
        }

        this.mouseMove = function(event) {
            if (this.currentPoint <= -1) {
                return;
            }
            var canvasRect = this.canvas.getBoundingClientRect();
            var newPosition = {
                x: Math.round(secondsPerDay * (event.pageX-canvasRect.left)/this.canvas.width / 60)  * 60,
                y: Math.round(maxY * (1.0-((event.pageY-canvasRect.top)/this.canvas.height)))
            };
            this.movePoint(this.currentPoint, newPosition);
        }

        this.movePoint = function(index, point){
            'use strict';

            const points = this.curve.points;
            if (index === 0) {
                point.x = clamp(point.x, 0, null);
            } else {
                point.x = clamp(point.x, points[index - 1].x + 1, null);
            }
            if (index === points.length - 1) {
                point.x = clamp(point.x, null, secondsPerDay - 1);
            } else {
                point.x = clamp(point.x, null, points[index + 1].x - 1);
            }
            this.curve.movePoint(index, point);
        }

        setInterval(() => this.render(), this.redrawInterval);
    }

    RED.nodes.registerType('time-curve',{
        category: 'function',
        color: '#a6bbcf',
        defaults: {
            name: {value:""},
            output_property: {value:"payload", required:true},
            input_property:  {value:"payload", required:true},
            points: {
                value: [
                    {x: Math.round(secondsPerDay/2), y: 50}
                ]
            }
        },
        inputs:1,
        outputs:1,
        icon: "time-curve.svg",
        label: function() {
            return this.name || "time-curve";
        },
        oneditprepare: function() {

            this.getPoint = function(uuid) {
                return this.curveView.curve.points.find(p => p.uuid === uuid);
            }

            const canvas = document.getElementById('curve-canvas');
            const container = canvas.parentElement;

            const curve = new Curve();
            this.curveView = new CurveView(canvas, container, curve);


            const nodered_sort = (pointA, pointB) => {
                try {
                    pointA = this.getPoint(pointA.uuid);
                    pointB = this.getPoint(pointB.uuid);
                    if        (pointA.x < pointB.x) {
                        return -1;
                    } else if (pointA.x > pointB.x) {
                        return +1;
                    }
                } catch (e) {}
                return 0;
            }

            const nodered_addItem = (row, index, point) => {

                let timeStr = '';
                if (isEmptyObject(point)) {
                    point.uuid = generateUUID();
                    point.x = NaN;
                    point.y = '';
                    this.curveView.curve.points = [];
                } else {
                    timeStr = secondsToTime(point.x);
                }

                $(row).html(`
                    Time: <input id="coord-input-x-${point.uuid}" class="coord-input-x" style="width: 75px; padding-right:2em;" type="time" step="1" value="${timeStr}">
                    Amplitude: <input id="coord-input-y-${point.uuid}" class="coord-input-y" style="width: 60px" type="number" min="0" max="100" step="0.1" value="${point.y}">%
                    <input type="hidden" class="coord-input-uuid" value="${point.uuid}">
                `);
                $(row).on('focusout', e => {
                    let points = parsePoints();
                    if (points.length > 0) {
                        // Only sort when data are valid.
                        $('#node-input-points-container').editableList('sort', nodered_sort);
                    }
                });
                $(row).on('change', e => {
                    let points = parsePoints();
                    this.curveView.curve.points = points;
                });
            }


            const nodered_removeItem = function(uuid){
                curve.removePoint(uuid);
            }

            $('#node-input-points-container').editableList({
                removable: true,
                addItem: nodered_addItem,
                removeItem: nodered_removeItem,
                sort: nodered_sort
            });

            // Initialize JavaScript Objects
            curve.onAddPoint = function(point){
                $('#node-input-points-container').editableList('addItem', point);
            }

            curve.onMovePoint = function(point){
                $(`#coord-input-x-${point.uuid}`).val(secondsToTime(point.x));
                $(`#coord-input-y-${point.uuid}`).val(point.y.toFixed(0));
            }

            curve.onRemovePoint = function(point){
                $('#node-input-points-container').editableList('removeItem', point);
            }

            for (let i=0; i<this.points.length; i++) {
                curve.addPoint(this.points[i]);
            }

            $("#node-input-input_property").typedInput({
                default:'msg',
                types:['msg']
            });
            $("#node-input-output_property").typedInput({
                default:'msg',
                types:['msg']
            });
        },
        oneditresize: function(size) {
            this.curveView.updateSize();
        },
        oneditsave: function(){
            this.points = parsePoints();
            // this.input_key = $("#node-input-input_prop").value();
            // this.output_key = $("#node-input-output_key").value();
        }
    });
</script>

<script type="text/x-red" data-template-name="time-curve">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input id="node-input-name" style="width: 70%" type="text" placeholder="time-curve">
    </div>
    <div class="form-row">
        <label for="node-input-input_property"><i class="fa fa-ellipsis-h"></i> Input</label>
        <input id="node-input-input_property" style="width: 70%" type="text">
    </div>
    <div class="form-row">
        <label for="node-input-output_property"><i class="fa fa-ellipsis-h"></i> Output</label>
        <input id="node-input-output_property" style="width: 70%" type="text">
    </div>
    <canvas id="curve-canvas" style="display:block;"></canvas>
    <span style="color:#999;">Click to add, drag to move, right click to delete.</span>
    <div class="form-row node-input-points-container-row" style="padding-top:0.5em;">
        <ol id="node-input-points-container"></ol>
    </div>
</script>

<script type="text/markdown" data-help-name="time-curve">
Takes a timestamp input and outputs a value based on the time of day.

### Inputs
: payload (timestamp) :  timestamp, for determining the time of day.

### Outputs
: payload (float) :  value based on time of day, as determined by config.

### Details
This node takes a timestamp input and outputs a percentage (float in the range 0.0 to 100.0 inclusive) based on the time of day of the timestamp.

This node functions as an analogue time clock, e.g. a time-based dimmer. I specifically designed it to program the brightness of aquarium lamps.

### Configuration
You can move points directly in the graph by clicking and dragging, add new points by clicking anywhere on the graph where one does not already exist, and delete points by right-clicking them.

Values between points are interpolated linearly, i.e. connected by a straight line. The last and first point are connected so that there is no jump in values at midnight.

</script>
