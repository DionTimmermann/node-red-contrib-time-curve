<script type="text/javascript">

    const secondsPerDay = 24 * 60 * 60;
    const maxY = 100;

    function secondsToTime(sec) {
        const hours = Math.floor(sec / 3600);
        const minutes = Math.floor((sec % 3600) / 60);
        const seconds = Math.floor(sec % 60);

        // Pad with leading zeros
        const pad = (n) => n.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }

    function timeToSeconds(timeStr) {
        const parts = timeStr.split(':').map(Number);
        const hours = parts[0] || 0;
        const minutes = parts[1] || 0;
        const seconds = parts[2] || 0;
        return hours * 3600 + minutes * 60 + seconds;
    }

    function clamp(value, min = null, max = null) {
        if (min !== null && value < min) value = min;
        if (max !== null && value > max) value = max;
        return value;
    }

    function parsePoints() {
        let points = $('#node-input-points-container').editableList('items');
        let list = [];
        try {
            points.each(function (i) {
                const x = timeToSeconds($(this).find('.coord-input-x').val());
                const y = parseFloat($(this).find('.coord-input-y').val());
                list.push({x: x, y: y, index: i});
            });
        } catch (e) {
            return [];
        }
        console.log(list);
        return list;
    }

    function Curve(config){
        'use strict';

        this.uid_seed       = 0;
        this.points 		= [];
        this.onAddPoint		= config.onAddPoint || function(index, point){};
        this.onMovePoint    = config.onMovePoint || function(index, point){};
        this.onRemovePoint  = config.onRemovePoint || function(index, point){};
        this.recalculate    = false;

        this.addPoint = function(point){
            this.recalculate = true;
            point.uid = this.uid_seed;
            this.uid_seed += 1;

            let index = this.points.findIndex(p => p.x > point.x);
            if (index === -1) {
                this.points.push(point);
                index = 0;
            } else {
                this.points.splice(index, 0, point);
            }

            point.index = index;
            this.onAddPoint(index, point);
        }

        this.removePoint = function(pointIndex, notify=true){
            this.recalculate = true;
            const point = this.points[pointIndex];
            this.points.splice(pointIndex, 1);
            if (notify) {
                this.onRemovePoint(pointIndex, point);
            }
        }

        this.movePoint = function(pointIndex, newValue){
            this.recalculate = true;
            this.points[pointIndex].x = newValue.x;
            this.points[pointIndex].y = newValue.y;
            newValue.index = pointIndex;
            newValue.uid = this.points[pointIndex].uid;
            this.onMovePoint(pointIndex, newValue);
        }

        this.getPositionOfPoint = function(uid){
            return this.points.map(p => p.uid).indexOf(uid);
        };

        this.getExtendedPoints = function() {
            const points = this.points;
            return [
                { x: points[points.length - 1].x - secondsPerDay, y: points[points.length - 1].y },
                ...points,
                { x: points[0].x + secondsPerDay, y: points[0].y }
            ];
        }

        if (config.points){
            for (let i=0; i < config.points.length; i++ ) {
                this.addPoint(config.points[i]);
            }
        }
    }

    function CurveView(canvas, container, curve){
        'use strict';

        this.currentPoint = -1;
        this.canvas			= canvas;
        this.canvas.width   = canvas.clientWidth;
        this.canvas.height  = 300;
        this.container      = container;
        this.curve          = curve;
        this.ctx 			= this.canvas.getContext('2d');
        this.stepSize       = 1.0/this.canvas.width;
        this.redrawInterval = 50;

        this.point_selection_threshold = 60*15;

        this.updateSize = function() {
            this.canvas.width = this.container.clientWidth;
        }

        this.canvas.addEventListener('mousedown', (ev) => {
            this.mouseDown(ev);
        }, false);

        this.canvas.addEventListener('contextmenu', (ev) => {
            this.rightClick(ev);
        }, false);

        this.canvas.addEventListener('mouseup', (ev) => {
            this.mouseUp(ev);
        }, false);

        this.canvas.addEventListener('mousemove', (ev) => {
            this.mouseMove(ev);
        }, false);

        this.pixelPositions = function(points) {
            const width = this.canvas.width;
            const height = this.canvas.height;
            return points.map(p => ({
                px: p.x * width / secondsPerDay,
                py: height - p.y * height / maxY
            }));
        }

        this.render = function() {
            'use strict';

            const extended = this.pixelPositions(this.curve.getExtendedPoints());
            const ctx = this.ctx;
            const width = this.canvas.width;
            const height = this.canvas.height;

            ctx.clearRect(0, 0, width, height);
            this.drawGrid(ctx);
            this.drawBorder(ctx);

            // Draw line
            this.ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000';
            ctx.moveTo(extended[0].px, extended[0].py);
            for(let i=1; i<extended.length; i++) {
                ctx.lineTo(extended[i].px, extended[i].py);
            }
            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            for(let i=1; i<extended.length-1; i++) {
                ctx.moveTo(extended[i].px, extended[i].py);
                ctx.arc(extended[i].px, extended[i].py, 3, 0 , 2*Math.PI);
            }
            this.ctx.fill();

        }

        // The background border
        this.drawBorder = function(ctx) {
            'use strict';

            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000000';
            ctx.rect(0, 0, this.canvas.width, this.canvas.height);
            ctx.stroke();
        }

        // The background grid
        this.drawGrid = function(ctx) {
            'use strict';

            const width = this.canvas.width;
            const height = this.canvas.height;

            // horrizontal lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#aaa';
            let numSections = 4;
            for (let i=1; i<numSections; i++) {
                let yCoord = Math.round(i * height/numSections);
                ctx.moveTo(0, yCoord);
                ctx.lineTo(width, yCoord);
            }
            ctx.stroke();

            // thin vertical lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ddd';
            numSections = 24;
            for (let i=1; i<numSections; i++) {
                if (i%6 == 0) {
                    continue;
                }
                let xCoord = Math.round(i * width/numSections);
                ctx.moveTo(xCoord, 0); ctx.lineTo(xCoord, height);
            }
            ctx.stroke();

            // dark vertical lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#999';
            numSections = 4;
            for (let i=1; i<numSections; i++) {
                let xCoord = Math.round(i * width/numSections);
                ctx.moveTo(xCoord, 0); ctx.lineTo(xCoord, height-16); // Offset a bit for the text
            }
            ctx.stroke();

            ctx.font = "14px Arial";
            ctx.fillStyle = "#999";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("6:00",  width * 1 / 4, height);
            ctx.fillText("12:00", width * 2 / 4, height);
            ctx.fillText("18:00", width * 3 / 4, height);

            ctx.textAlign = "left";    // left, right, center
            ctx.textBaseline = "top";
            ctx.fillText("25%",  2, height * 3 / 4);
            ctx.fillText("50%",  2, height * 2 / 4);
            ctx.fillText("75%",  2, height * 1 / 4);
            ctx.fillText("100%", 2, height * 0 / 4);
        }

        this.getCoordinateFromEvent = function(event){
            if(!event) var event = window.event;
            var canvasRect = this.canvas.getBoundingClientRect();
            var pointerCoordinate = {
                px: event.pageX - canvasRect.left,
                py: event.pageY - canvasRect.top
            }
            return pointerCoordinate;
        }

        this.mouseDown = function(event) {
            'use strict';
            const click = this.getCoordinateFromEvent(event);

            const points = this.pixelPositions(this.curve.points);
            const distances = points.map(p => Math.sqrt((p.px - click.px)**2 + (p.py - click.py)**2));
            const minDist = Math.min(...distances);

            if (minDist <= 10) {
                console.log('clicked point '+ distances.indexOf(minDist));
                this.currentPoint = distances.indexOf(minDist);
            } else {
                const newPoint = {
                    x: Math.round(click.px / canvas.width * secondsPerDay),
                    y: Math.round((1 - (click.py / canvas.height)) * maxY)
                }
                this.currentPoint = this.curve.addPoint(newPoint);
            }

        }

        this.rightClick = function(event) {
            'use strict';
            if (this.curve.points.length === 1) {
                return;
            }

            const click = this.getCoordinateFromEvent(event);

            const points = this.pixelPositions(this.curve.points);
            const distances = points.map(p => Math.sqrt((p.px - click.px)**2 + (p.py - click.py)**2));
            const minDist = Math.min(...distances);

            if (minDist <= 10) {
                this.curve.removePoint(distances.indexOf(minDist));
            }
        }

        this.mouseUp = function(event) {
            'use strict';
            this.currentPoint = -1;
        }

        this.mouseMove = function(event) {
            if (this.currentPoint == -1) return;
            var canvasRect = this.canvas.getBoundingClientRect();
            var newPosition = {
                x: Math.round(secondsPerDay * (event.pageX-canvasRect.left)/this.canvas.width / 60)  * 60,
                y: Math.round(maxY * (1.0-((event.pageY-canvasRect.top)/this.canvas.height)))
            };
            this.movePoint(this.currentPoint, newPosition);
        }

        this.movePoint = function(index, point){
            'use strict';

            const points = this.curve.points;
            if (index === 0) {
                point.x = clamp(point.x, 0, null);
            } else {
                point.x = clamp(point.x, points[index-1].x + 1, null);
            }
            if (index === points.length-1) {
                point.x = clamp(point.x, null, secondsPerDay - 1);
            } else {
                point.x = clamp(point.x, null, points[index+1].x - 1);
            }
            this.curve.movePoint(index, point);
        }

        setInterval(() => this.render(), this.redrawInterval);
    }

    RED.nodes.registerType('time-curve',{
        category: 'function',
        color: '#a6bbcf',
        defaults: {
            name: {value:""},
            output_key: {value: ""},
            input_key: {value: ""},
            points: {
                value: [
                    {x: secondsPerDay/2, y: 50}
                ]
            }
        },
        inputs:1,
        outputs:1,
        icon: "time-curve.svg",
        label: function() {
            return this.name||"time-curve";
        },
        oneditprepare: function() {

            const nodered_addItem = (row, index, point) => {
                $(row).html(`
                    Time: <input id="coord-input-x-${point.uid}" class="coord-input-x" style="width: 75px; padding-right:2em;" type="time" step="1" value="${secondsToTime(point.x)}">
                    Amplitude: <input id="coord-input-y-${point.uid}" class="coord-input-y" style="width: 60px" type="number" min="0" max="100" step="0.1" value="${point.y}">%
                `);
                $(row).on('change', e => {
                    // console.log('change');
                    // if(e.keyCode === 13){
                    //     const newLocation = {
                    //         x: timeToSeconds($(`#coord-input-x-${point.uid}`).val()),
                    //         y: parseFloat($(`#coord-input-y-${point.uid}`).val())
                    //     };
                    //     const index = curve.getPositionOfPoint(point.uid);
                    //     this.curveView.movePoint(index, newLocation);
                    // }
                    let points = parsePoints();
                    this.curveView.curve.points = points;
                    if (points.length !== 0) {
                        $('#node-inputer-points-container').editableList('sort');
                    }
                });
                $('#node-inputer-points-container').editableList('sort');
            }

            const nodered_sort = function(itemA, itemB){
                try {
                    return timeToSeconds(itemA.x) - timeToSeconds(itemB.x);
                } catch (e) {
                    return 0
                }
            }

            const nodered_removeItem = function(point){
                console.log('removed point: ', point);
                const position = curve.getPositionOfPoint(point.uid);
                if(position >= 0 ) curve.removePoint(position, false);
            }

            $('#node-input-points-container').editableList({
                removable: true,
                addItem: nodered_addItem,
                removeItem: nodered_removeItem,
                sort: nodered_sort
            });

            // Initialize JavaScript Objects
            const curve_onAddPoint = function(index, point){
                $('#node-input-points-container').editableList('addItem', point);
            }

            const curve_onMovePoint = function(index, point){
                $(`#coord-input-x-${point.uid}`).val(secondsToTime(point.x));
                $(`#coord-input-y-${point.uid}`).val(point.y.toFixed(0));
            }

            const curve_onRemovePoint = function(index, point){
                $('#node-input-points-container').editableList('removeItem', point);
            }

            config = {
                points: [],
                onAddPoint: curve_onAddPoint,
                onMovePoint: curve_onMovePoint,
                onRemovePoint: curve_onRemovePoint
            };

            for(let i=0; i<this.points.length; i++) {
                const point_raw = this.points[i];
                config.points.push({x: parseFloat(point_raw.x), y: parseFloat(point_raw.y)});
            }

            $("#node-input-input_key").typedInput({default:'msg',types:['msg']});
            $("#node-input-output_key").typedInput({default:'msg',types:['msg']});
            const canvas = document.getElementById('curve-canvas');
            const container = canvas.parentElement;

            const curve = new Curve(config);
            this.curveView = new CurveView(canvas, container, curve);
        },
        oneditresize: function(size) {
            this.curveView.updateSize();
        },
        oneditsave: function(){
            this.points = parsePoints();
        }
    });
</script>

<script type="text/x-red" data-template-name="time-curve">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input id="node-input-name" style="width: 70%" type="text" placeholder="time-curve">
    </div>
    <div class="form-row">
        <label for="node-input-input_key"><i class="fa fa-ellipsis-h"></i> Input</label>
        <input id="node-input-input_key" style="width: 70%" type="text" placeholder="payload">
    </div>
    <div class="form-row">
        <label for="node-input-output_key"><i class="fa fa-ellipsis-h"></i> Output</label>
        <input id="node-input-output_key" style="width: 70%" type="text" placeholder="payload">
    </div>
    <canvas id="curve-canvas" style="display:block;"></canvas>
    <div class="form-row node-input-points-container-row">
        <ol id="node-input-points-container"></ol>
    </div>
</script>

<script type="text/x-red" data-help-name="time-curve">
    <p>A simple node</p>

</script>
